{"ast":null,"code":"var _jsxFileName = \"/home/rgukt/Desktop/clonned/Faceshape-detection-using-MediaPipe-React-Js/src/App.js\",\n  _s = $RefreshSig$();\nimport logo from './logo.svg';\nimport './App.css';\nimport { FaceMesh } from \"@mediapipe/face_mesh\";\nimport React, { useRef, useEffect, useState } from \"react\";\nimport * as Facemesh from \"@mediapipe/face_mesh\";\nimport * as cam from \"@mediapipe/camera_utils\";\nimport Webcam from \"react-webcam\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction App() {\n  _s();\n  const [faceShape, setFaceShape] = useState(\"No face detected\");\n  const webcamRef = useRef(null);\n  const canvasRef = useRef(null);\n  const connect = window.drawConnectors;\n  var camera = null;\n  function calculateDistance(landmark1, landmark2) {\n    const x1 = landmark1['x']; // X-coordinate of landmark1\n    const y1 = landmark1['y']; // Y-coordinate of landmark1\n    const x2 = landmark2['x']; // X-coordinate of landmark2\n    const y2 = landmark2['y']; // Y-coordinate of landmark2\n\n    // Calculate Euclidean distance\n    const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n    return distance;\n  }\n  function onResults(results) {\n    // const video = webcamRef.current.video;\n    const videoWidth = webcamRef.current.video.videoWidth;\n    const videoHeight = webcamRef.current.video.videoHeight;\n\n    // Set canvas width\n    canvasRef.current.width = videoWidth;\n    canvasRef.current.height = videoHeight;\n    const canvasElement = canvasRef.current;\n    const canvasCtx = canvasElement.getContext(\"2d\");\n    canvasCtx.save();\n    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n    canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);\n    if (results.multiFaceLandmarks) {\n      const landmarksFaceShape = results.multiFaceLandmarks[0];\n      if (results !== null && results !== void 0 && results.multiFaceLandmarks[0]) {\n        const cheekboneDistance = calculateDistance(landmarksFaceShape[0], landmarksFaceShape[16]);\n        const faceWidth = calculateDistance(landmarksFaceShape[0], landmarksFaceShape[9]);\n        const faceLength = calculateDistance(landmarksFaceShape[27], landmarksFaceShape[8]);\n        const jawlineDistance = calculateDistance(landmarksFaceShape[0], landmarksFaceShape[16]);\n        const cheekboneDistance2 = calculateDistance(landmarksFaceShape[2], landmarksFaceShape[13]);\n        const foreheadWidth = calculateDistance(landmarksFaceShape[0], landmarksFaceShape[16]);\n        const jawlineWidth = calculateDistance(landmarksFaceShape[0], landmarksFaceShape[8]);\n        const chinToJawlineDistance = calculateDistance(landmarksFaceShape[9], landmarksFaceShape[8]);\n        const jawlineWidth2 = calculateDistance(landmarksFaceShape[0], landmarksFaceShape[16]);\n        const foreheadWidth2 = calculateDistance(landmarksFaceShape[21], landmarksFaceShape[22]);\n        if (cheekboneDistance > faceWidth && faceLength > faceWidth) {\n          setFaceShape(\"Diamond\");\n        } else if (jawlineDistance > faceWidth && jawlineDistance > faceLength) {\n          setFaceShape(\"Square\");\n        } else if (jawlineDistance < faceWidth && jawlineDistance < faceLength && cheekboneDistance2 > 1.2 * faceWidth) {\n          setFaceShape(\"Oval\");\n        } else if (foreheadWidth > jawlineWidth && chinToJawlineDistance < 0.7 * jawlineWidth) {\n          setFaceShape(\"Heart\");\n        } else if (jawlineDistance < 1.2 * faceWidth && faceWidth > 0.8 * faceLength && cheekboneDistance < 0.5 * faceWidth) {\n          setFaceShape(\"Round\");\n        } else if (jawlineWidth2 > 1.2 * foreheadWidth2 && chinToJawlineDistance > 1.2 * foreheadWidth2) {\n          setFaceShape(\"Triangle\");\n        } else {\n          setFaceShape(\"Can not detect\");\n        }\n      }\n      for (const landmarks of results.multiFaceLandmarks) {\n        connect(canvasCtx, landmarks, Facemesh.FACEMESH_TESSELATION, {\n          color: \"#eae8fd\",\n          lineWidth: 1\n        });\n        connect(canvasCtx, landmarks, Facemesh.FACEMESH_RIGHT_EYE, {\n          color: \"#7367f0\"\n        });\n        connect(canvasCtx, landmarks, Facemesh.FACEMESH_RIGHT_EYEBROW, {\n          color: \"#7367f0\"\n        });\n        connect(canvasCtx, landmarks, Facemesh.FACEMESH_LEFT_EYE, {\n          color: \"#7367f0\"\n        });\n        connect(canvasCtx, landmarks, Facemesh.FACEMESH_LEFT_EYEBROW, {\n          color: \"#7367f0\"\n        });\n        connect(canvasCtx, landmarks, Facemesh.FACEMESH_FACE_OVAL, {\n          color: \"#7367f0\"\n        });\n        connect(canvasCtx, landmarks, Facemesh.FACEMESH_LIPS, {\n          color: \"#7367f0\"\n        });\n      }\n    } else {\n      setFaceShape(\"No face detected\");\n    }\n    canvasCtx.restore();\n  }\n  // }\n\n  // setInterval(())\n  // setInterval(() => {\n\n  // }, 1000 * 5)\n  useEffect(() => {\n    const faceMesh = new FaceMesh({\n      locateFile: file => {\n        return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;\n      }\n    });\n    faceMesh.setOptions({\n      maxNumFaces: 1,\n      minDetectionConfidence: 0.5,\n      minTrackingConfidence: 0.5\n    });\n    faceMesh.onResults(onResults);\n    if (typeof webcamRef.current !== \"undefined\" && webcamRef.current !== null) {\n      camera = new cam.Camera(webcamRef.current.video, {\n        onFrame: async () => {\n          await faceMesh.send({\n            image: webcamRef.current.video\n          });\n        },\n        width: 640,\n        height: 480\n      });\n      camera.start();\n    }\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"App\",\n    children: /*#__PURE__*/_jsxDEV(\"header\", {\n      className: \"App-header\",\n      children: [/*#__PURE__*/_jsxDEV(\"center\", {\n        children: /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"App\",\n          children: [/*#__PURE__*/_jsxDEV(Webcam, {\n            ref: webcamRef,\n            style: {\n              textAlign: \"center\",\n              zindex: 9,\n              width: '300px',\n              height: 'auto',\n              display: 'none'\n            }\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 164,\n            columnNumber: 9\n          }, this), \" \", /*#__PURE__*/_jsxDEV(\"canvas\", {\n            ref: canvasRef,\n            className: \"output_canvas\",\n            style: {\n              zindex: 9,\n              width: '300px',\n              height: 'auto'\n            }\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 174,\n            columnNumber: 9\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 163,\n          columnNumber: 7\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 162,\n        columnNumber: 13\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: [\"My faceshape  \", /*#__PURE__*/_jsxDEV(\"code\", {\n          className: \"App-link\",\n          children: faceShape\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 186,\n          columnNumber: 25\n        }, this), \".\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 185,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 161,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 160,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"rbpcoGto2m7GBmSFPXPxhNJFKew=\");\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["logo","FaceMesh","React","useRef","useEffect","useState","Facemesh","cam","Webcam","jsxDEV","_jsxDEV","App","_s","faceShape","setFaceShape","webcamRef","canvasRef","connect","window","drawConnectors","camera","calculateDistance","landmark1","landmark2","x1","y1","x2","y2","distance","Math","sqrt","onResults","results","videoWidth","current","video","videoHeight","width","height","canvasElement","canvasCtx","getContext","save","clearRect","drawImage","image","multiFaceLandmarks","landmarksFaceShape","cheekboneDistance","faceWidth","faceLength","jawlineDistance","cheekboneDistance2","foreheadWidth","jawlineWidth","chinToJawlineDistance","jawlineWidth2","foreheadWidth2","landmarks","FACEMESH_TESSELATION","color","lineWidth","FACEMESH_RIGHT_EYE","FACEMESH_RIGHT_EYEBROW","FACEMESH_LEFT_EYE","FACEMESH_LEFT_EYEBROW","FACEMESH_FACE_OVAL","FACEMESH_LIPS","restore","faceMesh","locateFile","file","setOptions","maxNumFaces","minDetectionConfidence","minTrackingConfidence","Camera","onFrame","send","start","className","children","ref","style","textAlign","zindex","display","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/rgukt/Desktop/clonned/Faceshape-detection-using-MediaPipe-React-Js/src/App.js"],"sourcesContent":["import logo from './logo.svg';\nimport './App.css';\nimport { FaceMesh } from \"@mediapipe/face_mesh\";\nimport React, { useRef, useEffect, useState } from \"react\";\nimport * as Facemesh from \"@mediapipe/face_mesh\";\nimport * as cam from \"@mediapipe/camera_utils\";\nimport Webcam from \"react-webcam\";\n\n\nfunction App() {\n\n    const [faceShape, setFaceShape] = useState(\"No face detected\");\n    const webcamRef = useRef(null);\n    const canvasRef = useRef(null);\n    const connect = window.drawConnectors;\n    var camera = null;\n\n    function calculateDistance(landmark1, landmark2) {\n      const x1 = landmark1['x']; // X-coordinate of landmark1\n      const y1 = landmark1['y']; // Y-coordinate of landmark1\n      const x2 = landmark2['x']; // X-coordinate of landmark2\n      const y2 = landmark2['y']; // Y-coordinate of landmark2\n      \n      // Calculate Euclidean distance\n      const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n      return distance;\n    }\n\n    function onResults(results) {\n        // const video = webcamRef.current.video;\n        const videoWidth = webcamRef.current.video.videoWidth;\n        const videoHeight = webcamRef.current.video.videoHeight;\n\n        // Set canvas width\n        canvasRef.current.width = videoWidth;\n        canvasRef.current.height = videoHeight;\n\n        const canvasElement = canvasRef.current;\n        const canvasCtx = canvasElement.getContext(\"2d\");\n        canvasCtx.save();\n        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n        canvasCtx.drawImage(\n          results.image,\n          0,\n          0,\n          canvasElement.width,\n          canvasElement.height\n        );\n        if (results.multiFaceLandmarks) {\n          \n          const landmarksFaceShape = results.multiFaceLandmarks[0];\n          \n          if(results?.multiFaceLandmarks[0]){\n            const cheekboneDistance = calculateDistance(landmarksFaceShape[0], landmarksFaceShape[16]);\n            const faceWidth = calculateDistance(landmarksFaceShape[0], landmarksFaceShape[9]); \n            const faceLength = calculateDistance(landmarksFaceShape[27], landmarksFaceShape[8]);\n        \n            const jawlineDistance = calculateDistance(landmarksFaceShape[0], landmarksFaceShape[16]);\n            const cheekboneDistance2 = calculateDistance(landmarksFaceShape[2], landmarksFaceShape[13]);\n  \n\n            const foreheadWidth = calculateDistance(landmarksFaceShape[0], landmarksFaceShape[16]); \n            const jawlineWidth = calculateDistance(landmarksFaceShape[0], landmarksFaceShape[8]); \n            const chinToJawlineDistance = calculateDistance(landmarksFaceShape[9], landmarksFaceShape[8]); \n\n            const jawlineWidth2 = calculateDistance(landmarksFaceShape[0], landmarksFaceShape[16]);\n            const foreheadWidth2 = calculateDistance(landmarksFaceShape[21], landmarksFaceShape[22]);\n\n\n            if (cheekboneDistance > faceWidth && faceLength > faceWidth) {\n              setFaceShape(\"Diamond\");\n            }\n            else if (jawlineDistance > faceWidth && jawlineDistance > faceLength) {\n              setFaceShape(\"Square\");\n            }\n            else if (jawlineDistance < faceWidth && jawlineDistance < faceLength && cheekboneDistance2 > 1.2 * faceWidth) {\n              setFaceShape(\"Oval\");\n            }\n            else if (foreheadWidth > jawlineWidth && chinToJawlineDistance < 0.7 * jawlineWidth) {\n              setFaceShape(\"Heart\");\n            }\n            else if (jawlineDistance < 1.2 * faceWidth && faceWidth > 0.8 * faceLength && cheekboneDistance < 0.5 * faceWidth) {\n              setFaceShape(\"Round\");\n            }\n            else if (jawlineWidth2 > 1.2 * foreheadWidth2 && chinToJawlineDistance > 1.2 * foreheadWidth2) {\n              setFaceShape(\"Triangle\");\n            }\n            else{\n              setFaceShape(\"Can not detect\");\n            }\n          }\n            \n          for (const landmarks of results.multiFaceLandmarks) {\n            connect(canvasCtx, landmarks, Facemesh.FACEMESH_TESSELATION, {\n              color: \"#eae8fd\",\n              lineWidth: 1,\n            });\n            connect(canvasCtx, landmarks, Facemesh.FACEMESH_RIGHT_EYE, {\n              color: \"#7367f0\",\n            });\n            connect(canvasCtx, landmarks, Facemesh.FACEMESH_RIGHT_EYEBROW, {\n              color: \"#7367f0\",\n            });\n            connect(canvasCtx, landmarks, Facemesh.FACEMESH_LEFT_EYE, {\n              color: \"#7367f0\",\n            });\n            connect(canvasCtx, landmarks, Facemesh.FACEMESH_LEFT_EYEBROW, {\n              color: \"#7367f0\",\n            });\n            connect(canvasCtx, landmarks, Facemesh.FACEMESH_FACE_OVAL, {\n              color: \"#7367f0\",\n            });\n            connect(canvasCtx, landmarks, Facemesh.FACEMESH_LIPS, {\n              color: \"#7367f0\",\n            });\n          }\n        }\n        else {\n          setFaceShape(\"No face detected\");\n        }\n        canvasCtx.restore();\n      }\n      // }\n\n      // setInterval(())\n      // setInterval(() => {\n      \n      // }, 1000 * 5)\n      useEffect(() => {\n        const faceMesh = new FaceMesh({\n          locateFile: (file) => {\n            return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;\n          },\n        });\n\n        faceMesh.setOptions({\n          maxNumFaces: 1,\n          minDetectionConfidence: 0.5,\n          minTrackingConfidence: 0.5,\n        });\n\n        faceMesh.onResults(onResults);\n\n        if (\n          typeof webcamRef.current !== \"undefined\" &&\n          webcamRef.current !== null\n        ) {\n          camera = new cam.Camera(webcamRef.current.video, {\n            onFrame: async () => {\n              await faceMesh.send({ image: webcamRef.current.video });\n            },\n            width: 640,\n            height: 480,\n          });\n          camera.start();\n        }\n      }, []);\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n            <center>\n      <div className=\"App\">\n        <Webcam\n          ref={webcamRef}\n          style={{\n            textAlign: \"center\",\n            zindex: 9,\n            width: '300px',\n            height: 'auto',\n            display:'none'\n          }}\n        />{\" \"}\n        <canvas\n          ref={canvasRef}\n          className=\"output_canvas\"\n          style={{\n            zindex: 9,\n            width: '300px',\n            height: 'auto',\n          }}\n        ></canvas>\n      </div>\n    </center>\n        <p>\n          My faceshape  <code className=\"App-link\">{faceShape}</code>.\n        </p>\n\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}